!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/a794069/
Categorise	lexer/lexer.go	/^func Categorise(query string) string {$/;"	f	package:lexer
Check	checker/delete_no_where.go	/^func (dnw DeleteNoWhere) Check() LintResult {$/;"	f	unknown:checker.DeleteNoWhere
Check	checker/not_found_column.go	/^func (nfc NotFoundColumn) Check() int {$/;"	f	unknown:checker.NotFoundColumn
Check	checker/select_missing_expr.go	/^func (sme SelectMissingExpr) Check() int {$/;"	f	unknown:checker.SelectMissingExpr
Checker	checker/interface.go	/^type Checker interface {$/;"	i	package:checker
Column	checker/interface.go	/^	Column   int$/;"	m	struct:checker.LintResult
DeleteNoWhere	checker/delete_no_where.go	/^type DeleteNoWhere struct {$/;"	s	package:checker
Error struct	doc/rambles.md	/^#### Error struct   $/;"	t
Example (kinda)	doc/rambles.md	/^#### Example (kinda)$/;"	t
Flow	doc/how-it-works.md	/^# Flow $/;"	c
Formatter?	doc/rambles.md	/^### Formatter?$/;"	S
HasError	checker/interface.go	/^	HasError int$/;"	m	struct:checker.LintResult
Interface	doc/rambles.md	/^### Interface$/;"	S
Lexer	doc/rambles.md	/^## Lexer$/;"	s
Line	checker/interface.go	/^	Line     int$/;"	m	struct:checker.LintResult
LintResult	checker/interface.go	/^type LintResult struct {$/;"	s	package:checker
Message	checker/interface.go	/^	Message  string$/;"	m	struct:checker.LintResult
NotFoundColumn	checker/not_found_column.go	/^type NotFoundColumn struct {$/;"	s	package:checker
Ramblings & Ideas	doc/rambles.md	/^## Ramblings & Ideas$/;"	s
References	doc/rambles.md	/^## References $/;"	s
SelectMissingExpr	checker/select_missing_expr.go	/^type SelectMissingExpr struct {$/;"	s	package:checker
SqlQuery	checker/delete_no_where.go	/^	SqlQuery []string$/;"	m	struct:checker.DeleteNoWhere
SqlQuery	checker/not_found_column.go	/^	SqlQuery string$/;"	m	struct:checker.NotFoundColumn
SqlQuery	checker/select_missing_expr.go	/^	SqlQuery string$/;"	m	struct:checker.SelectMissingExpr
StringInSlice	lexer/lexer.go	/^func StringInSlice(s string, list []string) bool {$/;"	f	package:lexer
Structure	doc/rambles.md	/^### Structure$/;"	S
TestDeleteCheckerDoesNotWarnIfWherePresent	test/checker_test.go	/^func TestDeleteCheckerDoesNotWarnIfWherePresent(t *testing.T) {$/;"	f	package:lexer
TestDeleteCheckerWarnsAboutMissingWhere	test/checker_test.go	/^func TestDeleteCheckerWarnsAboutMissingWhere(t *testing.T) {$/;"	f	package:lexer
TestLexerCategorisesDeleteStatementsCorrectly	test/lexer_test.go	/^func TestLexerCategorisesDeleteStatementsCorrectly(t *testing.T) {$/;"	f	package:lexer
TestLexerCategorisesQueriesCorrectly	test/lexer_test.go	/^func TestLexerCategorisesQueriesCorrectly(t *testing.T) {$/;"	f	package:lexer
TestLexerCategorisesSelectStatementsCorrectly	test/lexer_test.go	/^func TestLexerCategorisesSelectStatementsCorrectly(t *testing.T) {$/;"	f	package:lexer
Tokenise	lexer/lexer.go	/^func Tokenise(query string) []string {$/;"	f	package:lexer
TokeniseDelete	lexer/delete.go	/^func TokeniseDelete(query string) []string {$/;"	f	package:lexer
TokeniseSelect	lexer/select.go	/^func TokeniseSelect(query string) []string {$/;"	f	package:lexer
Tokens	doc/rambles.md	/^### Tokens$/;"	S
Warnings & Messages	doc/rambles.md	/^### Warnings & Messages$/;"	S
checker	checker/delete_no_where.go	/^package checker$/;"	p
checker	checker/interface.go	/^package checker$/;"	p
checker	checker/not_found_column.go	/^package checker$/;"	p
checker	checker/select_missing_expr.go	/^package checker$/;"	p
lexer	lexer/delete.go	/^package lexer$/;"	p
lexer	lexer/lexer.go	/^package lexer$/;"	p
lexer	lexer/select.go	/^package lexer$/;"	p
lexer	test/checker_test.go	/^package lexer$/;"	p
lexer	test/lexer_test.go	/^package lexer$/;"	p
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
token	lexer/lexer.go	/^var token = map[string][]string{$/;"	v	package:lexer
